# Spring JDBC Project

## java method 호출과 parameter(argument, 매개변수)
* method(함수)를 호출할때 단순히 호출하는 방법과  
어떤 데이터를 전달하면서 호출하는 방법이 있다

* 단순히 호출하는 방법은 함수 안에서 데이터를 만들고,  
데이터를 연산하고 데이터를 출력한는 대부분의 기능을 구현한다.  
경우에 따라 전역적(public)으로 선언된 변수를 공유하면서 연산을 수행하기도 한다  
전역변수를 공유하면서 연산을 수행하는 것은 매우 불편한 코드가 만들어지고  
관리가 어렵고 이후에 bug가 발생할 확률이 매우 높다

* 데이터를 전달하면서 함수를 호출하는 방법은 호출하는 곳에서  
미리 데이터를 준비하고 함수에서는 전달받은 데이터를 연산하여 출력하거나 return

## 매개변수 전달방식
* call by Value, Call By Reference, Call By Name이 있다

### Call By Calue
* java에서 함수에 직접 값을 전달하기  
  add( 300, 500)
* primitive 변수에 값을 담고 전달하는 방식  
  int num1 = 300, num2 = 500
  add(num1, num2)

* 매개변수로 데이터를 전달받은 함수에서 데이터를 변환하여도 원래 원본 데이터를 변함이 없다

* 프로그래밍에서 가장 안전한 데이터 전달 방식이다
* 연산된 결과를 return하지 않으면 어떻게 연산이 되었는지 알수 있는 방법이 없다

### Call By Reference
* 함수에 매개변수를 전달할때 값을 전달하지 않고 값이 저장된 기억장수의 주소를 전달하는 방식

* 우리집에서 독특한 비빔밥을 만드는 레시피가 있다  
  그 레시피에는 우리집만의 재료에 대한 정보가 있다
* 친구가 우리집 비빔밥을 먹어보고 어떻게 만드는지 물어본다
* 말로 주저리 설명하지 않고 우리집 주소를 알려주고 우리집 냉장고에 재료가 있으니  
만들어 먹으라고 한다
* 친구는 우리집에 반문하여 냉장고 안의 재료를 가지고 비빔밥을 만들어 먹고  
  재료를 모두 소진한 것이 미안하여 한우 등심을 사서 냉장고에 넣어둔다
* 저역에 집에 가서 비빔밥을 만드려고 냉장고를 열었더니 재료가 바뀌었다

* Call By reference로 데이터를 전달받은 함수에서  
  변수의 값을 변경하면 원래 저장된 기억장소의 데이터가 변겨오디어  
  호출하기 이전에 만들어진 변수가 같이 바뀌게 된다

* C/C++ 에서는 포인터라는 개념을 사용해 Call By Reference를 구현한다

* java에서는 매개변수의 전달하는 개념이 모두 Call By Value이다
다만 내부에 다른 요소를 포함하는 클래스(VO, List, Map)으로 생성한 변수를 함수에 매개변수로 전달하였을 경우  
함수에서 전달받은 변수의 일부 요소를 변경 추가 삭제하면 원래 우너본 데이터에 변화가 생긴다

* 단 함수내에서 객체를 새로 생성(new...)하면 원본 데이터와 다른 데이터가 
 생성되는 결과가 되므로 원본 데이터에는 변화가 없다

* java는 클래스 type으로 변수를 만들때는 이러한 부분을 싱당히 신경써야 한다
 
* 다만 이러한 기능을 십분 활용한 다양한 코드 방법이 있다
* 이러한 기능을 화용한 대표적 코딩이 Spring의 controller내의 함수들이다

### Spring Controller의 함수들이 매개변수를 관리하는 방법
* 함수들을 선언할때 다양한 매개변수를 설정할 수 있다
* 종류 갯수에 관계 없이 자유롭게 필요한 매개변수를 설정하면
* Spring container는 Controller를 Bean으로 생성할때
* 각 함수의 시그니처에 맞도록 호출 코드를 생성해 둔다  
  void add(int num1, int num2), void add(String s1, String s2)// 시그니처가 다름

* 매개변수에 설정되는 클래스 타입 변수중 일부는 함수내에서 값을 변화(add, set, remove,clear)를 수행하면  
변수의 값이 변화되었다는 것을 Spring Container가 인지하고 적절하게 반응한다.

* 그러한 클래스형 변수중 대표적으로 Model, HttpSesstion등이 있다



# Http Protocol, Web Service의 Session

## Session
* point to point 관계에서 한번 연결이 이루어지면 파이프 라인과 같은 통로가 생성되고  
  그 통로를 통해 데이터를 전송하느낵념
* DBMS를 사용할때 사용자ID, Password를 사용하여 연결을 하면 임의로 연결을 끊기 전까지  
  연결이 유지되어 언제든이 명령을 보내고 데이터를 받을 수 있다

## HTTP Protocol에서는 기본적으로 Session이 없다
* stateless(상태없음)라고 표현한다
* client Request를 보내면 Server는 적절한 연산을 수행한 후 Reqponse를 하고 연결이 즉시 종료된다

## login개념
* Web Service로 구현한 여러 페이지 중에서 특정한 사용자 권한을 가진 겨우만 볼 수 있는 페이지가 있다고 하자
* client가 Request를 보내면, 사용자의 요청을 처리하기 전에 권한을 가진 사용자인지 검증을 하고 검증이 정상이면  
연산을 수행한 후 사용자에게 Reqponse를 시켜야한다
* 이때 각 페이지 마다 사용자의 정보를 수집하고 인증하고 정상인지 판단하여야 한다면  
많은 어려움과 불편함이 있을것이다

## HTTP Session
* 상태가 없는 (상태가 유지되지 않는) Web Service환경에서는
접근하는 사용자 정보를 확인하기 위해 매번 메뉴등을 클릭할때  
사용자 정보를 입력하고 시작해야 하는 방법으로 사용해야 한다
* 매우 초창기 Web에선느 그러한 방법을 사용하기도 했다

* 이후에 Session이라는 개념이 나오고 초기 기술로 쿠키라는 기술이 생겨났다
* 사용자가 최초로 login기능이 요청하여 login이 허락되면 서버에서 아주 작은 문자열 하나를 client에게 전달한다  
Cookie: 기술적인 규격이 정해진 문자열
* client는 서버로 부터 Cookie가 전달되면 운영체제의 정해진 폴더에 해당 파일을 저장해 놓는다  
쿠키에는 Server의 주소와 사용자 정보등이 기록되어 있다

* 이후에 client가 해당 Server에 Request를 보내면
브라우저는 쿠키가 저장된 폴더에서 해당 서버에 정보가 담긴 쿠키가 있는지 검사한다
* 있으면 http protocol에 쿠키 정보를 같이 포함해서 서버로 전송한다
* Server에서는 http protocol에 쿠키 정보가 담겨 있으면
그 정보를 바탕으로 다시 한번 인증을 수행한다
* 문제는 쿠키가 아무나 읽을 수 있는 일반(암호화되지 않은) text file이다
* 해커에 의해 언제든지 탈취될 수 있고 변형가능한 매우 보안에 취약한 기술이다

* 쿠키의 이러한 단점을 보완한 기술이 httpSession이다

## httpSession을 사용한 Session 유지 기술
* 로그인이 수행되어 정상적인 인증절차가 완료되면
* 서버는 Session 객체를 하나 생성하여 서버 메모리에 저장한다
* 여기에는 다양한 정보(속성, Attribute)를 포함하여 저장할수 있다
* 그리고 이 메모리의 주소를 특별한 방법으로 Hash하여 id값을 만들어낸다  
이 값을 Session ID라고 한다

* 이 Session id를 Client에게 쿠키 형태로 전달한다
* 이후에 같은 서버에 요청을 보내면 브라우저는 이 Session ID를 http Protocol에 실어서 보낸다

* 쿠키에 비하면 중요한 정보가 서버에 저장되므로 보다 안전하다 단,  
Session이 많아지면 서버의 메모리 사용량이 많아진다

* 이 httpession은 현존하는 Web Service에서 모두 지원하고 가장 많이 사용하는 방법이다
* 또한 매우 쉽게 구현 가능 하다.